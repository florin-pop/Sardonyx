// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: onnx/onnx.proto3
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.

// Copyright (c) ONNX Project Contributors.
// Licensed under the MIT license.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Versioning
///
/// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
///
/// To be compatible with both proto2 and proto3, we will use a version number
/// that is not defined by the default value but an explicit enum number.
public enum Onnx_Version: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// proto3 requires the first enum value to be zero.
  /// We add this just to appease the compiler.
  case startVersion // = 0

  /// The version field is always serialized and we will use it to store the
  /// version that the  graph is generated from. This helps us set up version
  /// control. 
  /// For the IR, we are using simple numbers starting with 0x00000001,
  /// which was the version we published on Oct 10, 2017.
  case irVersion20171010 // = 1

  /// IR_VERSION 2 published on Oct 30, 2017
  /// - Added type discriminator to AttributeProto to support proto3 users
  case irVersion20171030 // = 2

  /// IR VERSION 3 published on Nov 3, 2017
  /// - For operator versioning:
  ///    - Added new message OperatorSetIdProto
  ///    - Added opset_import in ModelProto
  /// - For vendor extensions, added domain in NodeProto
  case irVersion2017113 // = 3

  /// IR VERSION 4 published on Jan 22, 2019
  /// - Relax constraint that initializers should be a subset of graph inputs
  /// - Add type BFLOAT16
  case irVersion2019122 // = 4

  /// IR VERSION 5 published on March 18, 2019
  /// - Add message TensorAnnotation.
  /// - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
  case irVersion2019318 // = 5

  /// IR VERSION 6 published on Sep 19, 2019
  /// - Add support for sparse tensor constants stored in model.
  ///   - Add message SparseTensorProto
  ///   - Add sparse initializers
  case irVersion2019919 // = 6

  /// IR VERSION 7 published on <TBD>
  /// - Add support to allow function body graph to rely on multiple external opreator sets.
  /// - Add a list to promote inference graph's initializers to global and
  ///   mutable variables. Global variables are visible in all graphs of the
  ///   stored models.
  /// - Add message TrainingInfoProto to store initialization
  ///   method and training algorithm. The execution of TrainingInfoProto
  ///   can modify the values of mutable variables.
  /// - Make inference graph callable from TrainingInfoProto via GraphCall operator.
  case irVersion // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .startVersion
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startVersion
    case 1: self = .irVersion20171010
    case 2: self = .irVersion20171030
    case 3: self = .irVersion2017113
    case 4: self = .irVersion2019122
    case 5: self = .irVersion2019318
    case 6: self = .irVersion2019919
    case 7: self = .irVersion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .startVersion: return 0
    case .irVersion20171010: return 1
    case .irVersion20171030: return 2
    case .irVersion2017113: return 3
    case .irVersion2019122: return 4
    case .irVersion2019318: return 5
    case .irVersion2019919: return 6
    case .irVersion: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Onnx_Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Onnx_Version] = [
    .startVersion,
    .irVersion20171010,
    .irVersion20171030,
    .irVersion2017113,
    .irVersion2019122,
    .irVersion2019318,
    .irVersion2019919,
    .irVersion,
  ]
}

#endif  // swift(>=4.2)

/// Attributes
///
/// A named attribute containing either singular float, integer, string, graph,
/// and tensor values, or repeated float, integer, string, graph, and tensor values.
/// An AttributeProto MUST contain the name field, and *only one* of the
/// following content fields, effectively enforcing a C/C++ union equivalent.
public struct Onnx_AttributeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name field MUST be present for this version of the IR.
  public var name: String = String()

  /// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
  /// In this case, this AttributeProto does not contain data, and it's a reference of attribute
  /// in parent scope.
  /// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
  public var refAttrName: String = String()

  /// A human-readable documentation for this attribute. Markdown is allowed.
  public var docString: String = String()

  /// The type field MUST be present for this version of the IR.
  /// For 0.0.1 versions of the IR, this field was not defined, and
  /// implementations needed to use has_field heuristics to determine
  /// which value field was in use.  For IR_VERSION 0.0.2 or later, this
  /// field MUST be set and match the f|i|s|t|... field in use.  This
  /// change was made to accommodate proto3 implementations.
  public var type: Onnx_AttributeProto.AttributeType = .undefined

  /// Exactly ONE of the following fields must be present for this version of the IR
  public var f: Float = 0

  /// int
  public var i: Int64 = 0

  /// UTF-8 string
  public var s: Data = SwiftProtobuf.Internal.emptyData

  /// tensor value
  public var t: Onnx_TensorProto {
    get {return _t ?? Onnx_TensorProto()}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  public var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  public mutating func clearT() {self._t = nil}

  /// graph
  public var g: Onnx_GraphProto {
    get {return _g ?? Onnx_GraphProto()}
    set {_g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  public var hasG: Bool {return self._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  public mutating func clearG() {self._g = nil}

  /// sparse tensor value
  public var sparseTensor: Onnx_SparseTensorProto {
    get {return _sparseTensor ?? Onnx_SparseTensorProto()}
    set {_sparseTensor = newValue}
  }
  /// Returns true if `sparseTensor` has been explicitly set.
  public var hasSparseTensor: Bool {return self._sparseTensor != nil}
  /// Clears the value of `sparseTensor`. Subsequent reads from it will return its default value.
  public mutating func clearSparseTensor() {self._sparseTensor = nil}

  /// list of floats
  public var floats: [Float] = []

  /// list of ints
  public var ints: [Int64] = []

  /// list of UTF-8 strings
  public var strings: [Data] = []

  /// list of tensors
  public var tensors: [Onnx_TensorProto] = []

  /// list of graph
  public var graphs: [Onnx_GraphProto] = []

  /// list of sparse tensors
  public var sparseTensors: [Onnx_SparseTensorProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Note: this enum is structurally identical to the OpSchema::AttrType
  /// enum defined in schema.h.  If you rev one, you likely need to rev the other.
  public enum AttributeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case undefined // = 0
    case float // = 1
    case int // = 2
    case string // = 3
    case tensor // = 4
    case graph // = 5
    case sparseTensor // = 11
    case floats // = 6
    case ints // = 7
    case strings // = 8
    case tensors // = 9
    case graphs // = 10
    case sparseTensors // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .undefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .int
      case 3: self = .string
      case 4: self = .tensor
      case 5: self = .graph
      case 6: self = .floats
      case 7: self = .ints
      case 8: self = .strings
      case 9: self = .tensors
      case 10: self = .graphs
      case 11: self = .sparseTensor
      case 12: self = .sparseTensors
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .int: return 2
      case .string: return 3
      case .tensor: return 4
      case .graph: return 5
      case .floats: return 6
      case .ints: return 7
      case .strings: return 8
      case .tensors: return 9
      case .graphs: return 10
      case .sparseTensor: return 11
      case .sparseTensors: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _t: Onnx_TensorProto? = nil
  fileprivate var _g: Onnx_GraphProto? = nil
  fileprivate var _sparseTensor: Onnx_SparseTensorProto? = nil
}

#if swift(>=4.2)

extension Onnx_AttributeProto.AttributeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Onnx_AttributeProto.AttributeType] = [
    .undefined,
    .float,
    .int,
    .string,
    .tensor,
    .graph,
    .sparseTensor,
    .floats,
    .ints,
    .strings,
    .tensors,
    .graphs,
    .sparseTensors,
  ]
}

#endif  // swift(>=4.2)

/// Defines information on value, including the name, the type, and
/// the shape of the value.
public struct Onnx_ValueInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field MUST be present in this version of the IR.
  public var name: String = String()

  /// This field MUST be present in this version of the IR for
  /// inputs and outputs of the top-level graph.
  public var type: Onnx_TypeProto {
    get {return _type ?? Onnx_TypeProto()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// A human-readable documentation for this value. Markdown is allowed.
  public var docString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Onnx_TypeProto? = nil
}

/// Nodes
///
/// Computation graphs are made up of a DAG of nodes, which represent what is
/// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
///
/// For example, it can be a node of type "Conv" that takes in an image, a filter 
/// tensor and a bias tensor, and produces the convolved output.
public struct Onnx_NodeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// namespace Value
  public var input: [String] = []

  /// namespace Value
  public var output: [String] = []

  /// An optional identifier for this node in a graph.
  /// This field MAY be absent in ths version of the IR.
  public var name: String = String()

  /// The symbolic identifier of the Operator to execute.
  public var opType: String = String()

  /// The domain of the OperatorSet that specifies the operator named by op_type.
  public var domain: String = String()

  /// Additional named attributes.
  public var attribute: [Onnx_AttributeProto] = []

  /// A human-readable documentation for this node. Markdown is allowed.
  public var docString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Training information
/// TrainingInfoProto stores information for training a model.
/// In particular, this defines two functionalities: an initialization-step
/// and a training-algorithm-step. Initialization resets the model
/// back to its original state as if no training has been consumed.
/// Training algorithm improves the model based on input data.
///
/// The semantics of the initialization-step is that the initializers
/// in ModelProto.graph and in TrainingInfoProto.algorithm are first
/// initialized as specified by the initializers in the graph, and then
/// updated by the "initialization_binding" in every instance in
/// ModelProto.training_info.
///
/// The field "algorithm" defines a computation graph which represents a
/// training algorithm's step. After the execution of a
/// TrainingInfoProto.algorithm, the initializers specified by "update_binding"
/// may be immediately updated. If the targeted training algorithm contains
/// consecutive update stages (such as block coordinate descent methods),
/// the user needs to create a TrainingInfoProto for each stage.
public struct Onnx_TrainingInfoProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field describes a graph to compute the initial tensors
  /// upon starting the training process. Initialization graph has no input
  /// and can have multiple outputs. Usually, trainable tensors in neural
  /// networks are randomly initialized. To achieve that, for each tensor,
  /// the user can put a random number operator such as RandomNormal or
  /// RandomUniform in TrainingInfoProto.initialization.node and assign its
  /// random output to the specific tensor using "initialization_binding".
  /// This graph can also set the initializers in "algorithm" in the same
  /// TrainingInfoProto; a use case is resetting the number of training
  /// iteration to zero.
  ///
  /// By default, this field is an empty graph and its evaluation does not
  /// produce any output.
  public var initialization: Onnx_GraphProto {
    get {return _initialization ?? Onnx_GraphProto()}
    set {_initialization = newValue}
  }
  /// Returns true if `initialization` has been explicitly set.
  public var hasInitialization: Bool {return self._initialization != nil}
  /// Clears the value of `initialization`. Subsequent reads from it will return its default value.
  public mutating func clearInitialization() {self._initialization = nil}

  /// This field represents a training algorithm step. Given required inputs,
  /// it computes outputs to update initializers in its own or inference graph's
  /// initializer lists. In general, this graph contains loss node, gradient node,
  /// optimizer node, increment of iteration count, and some calls to the inference
  /// graph.
  ///
  /// The field algorithm.node is the only place the user can use GraphCall
  /// operator. The only callable graph is the one stored in ModelProto.graph.
  ///
  /// By default, this field is an empty graph and its evaluation does not
  /// produce any output.
  public var algorithm: Onnx_GraphProto {
    get {return _algorithm ?? Onnx_GraphProto()}
    set {_algorithm = newValue}
  }
  /// Returns true if `algorithm` has been explicitly set.
  public var hasAlgorithm: Bool {return self._algorithm != nil}
  /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
  public mutating func clearAlgorithm() {self._algorithm = nil}

  /// This field specifies the bindings from the outputs of "initialization" to
  /// some initializers in "ModelProto.graph.initializer" and 
  /// the "algorithm.initializer" in the same TrainingInfoProto.
  /// See "update_binding" below for details.
  ///
  /// By default, this field is empty and no initializer would be changed
  /// by the execution of "initialization".
  public var initializationBinding: [Onnx_StringStringEntryProto] = []

  /// Gradient-based training is usually an iterative procedure. In one gradient
  /// descent iteration, we apply
  ///
  /// x = x - r * g
  ///
  /// where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
  /// gradient of "x" with respect to a chosen loss. To avoid adding assignments
  /// into the training graph, we split the update equation into
  ///
  /// y = x - r * g
  /// x = y
  ///
  /// The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
  /// tell that "y" should be assigned to "x", the field "update_binding" may
  /// contain a key-value pair of strings, "x" (key of StringStringEntryProto)
  /// and "y" (value of StringStringEntryProto).
  /// For a neural network with multiple trainable (mutable) tensors, there can
  /// be multiple key-value pairs in "update_binding".
  ///
  /// The initializers appears as keys in "update_binding" are considered
  /// mutable and globally-visible variables. This implies some behaviors
  /// as described below.
  ///
  ///  1. We have only unique keys in all "update_binding"s so that two global
  ///     variables may not have the same name. This ensures that one
  ///     global variable is assigned up to once.
  ///  2. The keys must appear in names of "ModelProto.graph.initializer" or
  ///     "TrainingInfoProto.algorithm.initializer".
  ///  3. The values must be output names of "algorithm".
  ///  4. If an optional input of a graph is omitted when using GraphCall, the
  ///     global variable with the same name may be used.
  ///  5. When using GraphCall, the users always can pass values to optional 
  ///     inputs of the called graph even if the associated initializers appears
  ///     as keys in "update_binding"s.
  ///  6. The graphs in TrainingInfoProto's can use global variables as
  ///     their operator inputs.
  ///  7. Mutable variables are initialized to the value specified by the
  ///     corresponding initializer, and then potentially updated by
  ///     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
  ///
  /// This field usually contains names of trainable tensors
  /// (in ModelProto.graph), optimizer states such as momentums in advanced
  /// stochastic gradient methods (in TrainingInfoProto.graph),
  /// and number of training iterations (in TrainingInfoProto.graph).
  ///
  /// By default, this field is empty and no initializer would be changed
  /// by the execution of "algorithm".
  public var updateBinding: [Onnx_StringStringEntryProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialization: Onnx_GraphProto? = nil
  fileprivate var _algorithm: Onnx_GraphProto? = nil
}

/// Models
///
/// ModelProto is a top-level file/container format for bundling a ML model and
/// associating its computation graph with metadata.
///
/// The semantics of the model are described by the associated GraphProto's.
public struct Onnx_ModelProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the IR this model targets. See Version enum above.
  /// This field MUST be present.
  public var irVersion: Int64 = 0

  /// The OperatorSets this model relies on.
  /// All ModelProtos MUST have at least one entry that
  /// specifies which version of the ONNX OperatorSet is
  /// being imported.
  ///
  /// All nodes in the ModelProto's graph will bind against the operator
  /// with the same-domain/same-op_type operator with the HIGHEST version
  /// in the referenced operator sets.
  public var opsetImport: [Onnx_OperatorSetIdProto] = []

  /// The name of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  public var producerName: String = String()

  /// The version of the framework or tool used to generate this model.
  /// This field SHOULD be present to indicate which implementation/tool/framework
  /// emitted the model.
  public var producerVersion: String = String()

  /// Domain name of the model.
  /// We use reverse domain names as name space indicators. For example:
  /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
  ///
  /// Together with `model_version` and GraphProto.name, this forms the unique identity of
  /// the graph.
  public var domain: String = String()

  /// The version of the graph encoded. See Version enum below.
  public var modelVersion: Int64 = 0

  /// A human-readable documentation for this model. Markdown is allowed.
  public var docString: String = String()

  /// The parameterized graph that is evaluated to execute the model.
  public var graph: Onnx_GraphProto {
    get {return _graph ?? Onnx_GraphProto()}
    set {_graph = newValue}
  }
  /// Returns true if `graph` has been explicitly set.
  public var hasGraph: Bool {return self._graph != nil}
  /// Clears the value of `graph`. Subsequent reads from it will return its default value.
  public mutating func clearGraph() {self._graph = nil}

  /// Named metadata values; keys should be distinct.
  public var metadataProps: [Onnx_StringStringEntryProto] = []

  /// Training-specific information. Sequentially executing all stored
  /// `TrainingInfoProto.algorithm`s and assigning their outputs following
  /// the corresponding `TrainingInfoProto.update_binding`s is one training
  /// iteration. Similarly, to initialize the model
  /// (as if training hasn't happened), the user should sequentially execute
  /// all stored `TrainingInfoProto.initialization`s and assigns their outputs
  /// using `TrainingInfoProto.initialization_binding`s.
  ///
  /// If this field is empty, the training behavior of the model is undefined.
  public var trainingInfo: [Onnx_TrainingInfoProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _graph: Onnx_GraphProto? = nil
}

/// StringStringEntryProto follows the pattern for cross-proto-version maps.
/// See https://developers.google.com/protocol-buffers/docs/proto3#maps
public struct Onnx_StringStringEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Onnx_TensorAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tensorName: String = String()

  /// <key, value> pairs to annotate tensor specified by <tensor_name> above.
  /// The keys used in the mapping below must be pre-defined in ONNX spec.
  /// For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
  /// quantization parameter keys.
  public var quantParameterTensorNames: [Onnx_StringStringEntryProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Graphs
///
/// A graph defines the computational logic of a model and is comprised of a parameterized 
/// list of nodes that form a directed acyclic graph based on their inputs and outputs.
/// This is the equivalent of the "network" or "graph" in many deep learning
/// frameworks.
public struct Onnx_GraphProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nodes in the graph, sorted topologically.
  public var node: [Onnx_NodeProto] = []

  /// The name of the graph.
  public var name: String = String()

  /// A list of named tensor values, used to specify constant inputs of the graph.
  /// Each TensorProto entry must have a distinct name (within the list) that
  /// MAY also appear in the input list.
  public var initializer: [Onnx_TensorProto] = []

  /// Initializers (see above) stored in sparse format.
  public var sparseInitializer: [Onnx_SparseTensorProto] = []

  /// A human-readable documentation for this graph. Markdown is allowed.
  public var docString: String = String()

  /// The inputs and outputs of the graph.
  public var input: [Onnx_ValueInfoProto] = []

  public var output: [Onnx_ValueInfoProto] = []

  /// Information for the values in the graph. The ValueInfoProto.name's
  /// must be distinct. It is optional for a value to appear in value_info list.
  public var valueInfo: [Onnx_ValueInfoProto] = []

  /// This field carries information to indicate the mapping among a tensor and its
  /// quantization parameter tensors. For example:
  /// For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
  /// which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
  public var quantizationAnnotation: [Onnx_TensorAnnotation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tensors
///
/// A serialized tensor value.
public struct Onnx_TensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shape of the tensor.
  public var dims: [Int64] = []

  /// The data type of the tensor.
  /// This field MUST have a valid TensorProto.DataType value
  public var dataType: Int32 = 0

  public var segment: Onnx_TensorProto.Segment {
    get {return _segment ?? Onnx_TensorProto.Segment()}
    set {_segment = newValue}
  }
  /// Returns true if `segment` has been explicitly set.
  public var hasSegment: Bool {return self._segment != nil}
  /// Clears the value of `segment`. Subsequent reads from it will return its default value.
  public mutating func clearSegment() {self._segment = nil}

  /// For float and complex64 values
  /// Complex64 tensors are encoded as a single array of floats,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component appearing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
  public var floatData: [Float] = []

  /// For int32, uint8, int8, uint16, int16, bool, and float16 values
  /// float16 values must be bit-wise converted to an uint16_t prior
  /// to writing to the buffer.
  /// When this field is present, the data_type field MUST be
  /// INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
  public var int32Data: [Int32] = []

  /// For strings.
  /// Each element of string_data is a UTF-8 encoded Unicode
  /// string. No trailing null, no leading BOM. The protobuf "string"
  /// scalar type is not used to match ML community conventions.
  /// When this field is present, the data_type field MUST be STRING
  public var stringData: [Data] = []

  /// For int64.
  /// When this field is present, the data_type field MUST be INT64
  public var int64Data: [Int64] = []

  /// Optionally, a name for the tensor.
  public var name: String = String()

  /// A human-readable documentation for this tensor. Markdown is allowed.
  public var docString: String = String()

  /// Serializations can either use one of the fields above, or use this
  /// raw bytes field. The only exception is the string case, where one is
  /// required to store the content in the repeated bytes string_data field.
  ///
  /// When this raw_data field is used to store tensor value, elements MUST
  /// be stored in as fixed-width, little-endian order.
  /// Floating-point data types MUST be stored in IEEE 754 format.
  /// Complex64 elements must be written as two consecutive FLOAT values, real component first.
  /// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
  /// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
  ///
  /// Note: the advantage of specific field rather than the raw_data field is
  /// that in some cases (e.g. int data), protobuf does a better packing via
  /// variable length storage, and may lead to smaller binary footprint.
  /// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
  public var rawData: Data = SwiftProtobuf.Internal.emptyData

  /// Data can be stored inside the protobuf file using type-specific fields or raw_data.
  /// Alternatively, raw bytes data can be stored in an external file, using the external_data field.
  /// external_data stores key-value pairs describing data location. Recognized keys are:
  /// - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
  ///                           protobuf model was stored
  /// - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
  ///                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
  /// - "length" (optional) - number of bytes containing data. Integer stored as string.
  /// - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
  public var externalData: [Onnx_StringStringEntryProto] = []

  /// If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
  public var dataLocation: Onnx_TensorProto.DataLocation = .default

  /// For double
  /// Complex128 tensors are encoded as a single array of doubles,
  /// with the real components appearing in odd numbered positions,
  /// and the corresponding imaginary component appearing in the
  /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
  /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
  /// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
  public var doubleData: [Double] = []

  /// For uint64 and uint32 values
  /// When this field is present, the data_type field MUST be
  /// UINT32 or UINT64
  public var uint64Data: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DataType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case undefined // = 0

    /// Basic types.
    case float // = 1

    /// uint8_t
    case uint8 // = 2

    /// int8_t
    case int8 // = 3

    /// uint16_t
    case uint16 // = 4

    /// int16_t
    case int16 // = 5

    /// int32_t
    case int32 // = 6

    /// int64_t
    case int64 // = 7

    /// string
    case string // = 8

    /// bool
    case bool // = 9

    /// IEEE754 half-precision floating-point format (16 bits wide).
    /// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
    case float16 // = 10
    case double // = 11
    case uint32 // = 12
    case uint64 // = 13

    /// complex with float32 real and imaginary components
    case complex64 // = 14

    /// complex with float64 real and imaginary components
    case complex128 // = 15

    /// Non-IEEE floating-point format based on IEEE754 single-precision
    /// floating-point number truncated to 16 bits.
    /// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
    case bfloat16 // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .undefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .float
      case 2: self = .uint8
      case 3: self = .int8
      case 4: self = .uint16
      case 5: self = .int16
      case 6: self = .int32
      case 7: self = .int64
      case 8: self = .string
      case 9: self = .bool
      case 10: self = .float16
      case 11: self = .double
      case 12: self = .uint32
      case 13: self = .uint64
      case 14: self = .complex64
      case 15: self = .complex128
      case 16: self = .bfloat16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .float: return 1
      case .uint8: return 2
      case .int8: return 3
      case .uint16: return 4
      case .int16: return 5
      case .int32: return 6
      case .int64: return 7
      case .string: return 8
      case .bool: return 9
      case .float16: return 10
      case .double: return 11
      case .uint32: return 12
      case .uint64: return 13
      case .complex64: return 14
      case .complex128: return 15
      case .bfloat16: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Location of the data for this tensor. MUST be one of:
  /// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
  /// - EXTERNAL - data stored in an external location as described by external_data field.
  public enum DataLocation: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case `default` // = 0
    case external // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .external
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .external: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// For very large tensors, we may want to store them in chunks, in which
  /// case the following fields will specify the segment that is stored in
  /// the current TensorProto.
  public struct Segment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var begin: Int64 = 0

    public var end: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _segment: Onnx_TensorProto.Segment? = nil
}

#if swift(>=4.2)

extension Onnx_TensorProto.DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Onnx_TensorProto.DataType] = [
    .undefined,
    .float,
    .uint8,
    .int8,
    .uint16,
    .int16,
    .int32,
    .int64,
    .string,
    .bool,
    .float16,
    .double,
    .uint32,
    .uint64,
    .complex64,
    .complex128,
    .bfloat16,
  ]
}

extension Onnx_TensorProto.DataLocation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Onnx_TensorProto.DataLocation] = [
    .default,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// A serialized sparse-tensor value
public struct Onnx_SparseTensorProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sequence of non-default values are encoded as a tensor of shape [NNZ].
  /// The default-value is zero for numeric tensors, and empty-string for string tensors.
  public var values: Onnx_TensorProto {
    get {return _values ?? Onnx_TensorProto()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  public var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  public mutating func clearValues() {self._values = nil}

  /// The indices of the non-default values, which may be stored in one of two formats.
  /// (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
  /// corresponding to the j-th index of the i-th value (in the values tensor).
  /// (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
  /// must be the linearized-index of the i-th value (in the values tensor).
  /// The linearized-index can be converted into an index tuple (k_1,...,k_rank)
  /// using the shape provided below.
  /// The indices must appear in ascending order without duplication.
  /// In the first format, the ordering is lexicographic-ordering:
  /// e.g., index-value [1,4] must appear before [2,1]
  public var indices: Onnx_TensorProto {
    get {return _indices ?? Onnx_TensorProto()}
    set {_indices = newValue}
  }
  /// Returns true if `indices` has been explicitly set.
  public var hasIndices: Bool {return self._indices != nil}
  /// Clears the value of `indices`. Subsequent reads from it will return its default value.
  public mutating func clearIndices() {self._indices = nil}

  /// The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
  public var dims: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _values: Onnx_TensorProto? = nil
  fileprivate var _indices: Onnx_TensorProto? = nil
}

/// Defines a tensor shape. A dimension can be either an integer value
/// or a symbolic variable. A symbolic variable represents an unknown
/// dimension.
public struct Onnx_TensorShapeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dim: [Onnx_TensorShapeProto.Dimension] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Dimension {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: Onnx_TensorShapeProto.Dimension.OneOf_Value? = nil

    public var dimValue: Int64 {
      get {
        if case .dimValue(let v)? = value {return v}
        return 0
      }
      set {value = .dimValue(newValue)}
    }

    /// namespace Shape
    public var dimParam: String {
      get {
        if case .dimParam(let v)? = value {return v}
        return String()
      }
      set {value = .dimParam(newValue)}
    }

    /// Standard denotation can optionally be used to denote tensor
    /// dimensions with standard semantic descriptions to ensure
    /// that operations are applied to the correct axis of a tensor.
    /// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
    /// for pre-defined dimension denotations.
    public var denotation: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Value: Equatable {
      case dimValue(Int64)
      /// namespace Shape
      case dimParam(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Onnx_TensorShapeProto.Dimension.OneOf_Value, rhs: Onnx_TensorShapeProto.Dimension.OneOf_Value) -> Bool {
        switch (lhs, rhs) {
        case (.dimValue(let l), .dimValue(let r)): return l == r
        case (.dimParam(let l), .dimParam(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// Types
///
/// The standard ONNX data types.
public struct Onnx_TypeProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// The type of a tensor.
  public var tensorType: Onnx_TypeProto.Tensor {
    get {
      if case .tensorType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Tensor()
    }
    set {_uniqueStorage()._value = .tensorType(newValue)}
  }

  /// The type of a sequence.
  public var sequenceType: Onnx_TypeProto.Sequence {
    get {
      if case .sequenceType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Sequence()
    }
    set {_uniqueStorage()._value = .sequenceType(newValue)}
  }

  /// The type of a map.
  public var mapType: Onnx_TypeProto.Map {
    get {
      if case .mapType(let v)? = _storage._value {return v}
      return Onnx_TypeProto.Map()
    }
    set {_uniqueStorage()._value = .mapType(newValue)}
  }

  /// An optional denotation can be used to denote the whole 
  /// type with a standard semantic description as to what is 
  /// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
  /// for pre-defined type denotations.
  public var denotation: String {
    get {return _storage._denotation}
    set {_uniqueStorage()._denotation = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    /// The type of a tensor.
    case tensorType(Onnx_TypeProto.Tensor)
    /// The type of a sequence.
    case sequenceType(Onnx_TypeProto.Sequence)
    /// The type of a map.
    case mapType(Onnx_TypeProto.Map)

  #if !swift(>=4.1)
    public static func ==(lhs: Onnx_TypeProto.OneOf_Value, rhs: Onnx_TypeProto.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.tensorType(let l), .tensorType(let r)): return l == r
      case (.sequenceType(let l), .sequenceType(let r)): return l == r
      case (.mapType(let l), .mapType(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct Tensor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST NOT have the value of UNDEFINED
    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    public var elemType: Int32 = 0

    public var shape: Onnx_TensorShapeProto {
      get {return _shape ?? Onnx_TensorShapeProto()}
      set {_shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    public var hasShape: Bool {return self._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    public mutating func clearShape() {self._shape = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _shape: Onnx_TensorShapeProto? = nil
  }

  /// repeated T
  public struct Sequence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type and optional shape of each element of the sequence.
    /// This field MUST be present for this version of the IR.
    public var elemType: Onnx_TypeProto {
      get {return _storage._elemType ?? Onnx_TypeProto()}
      set {_uniqueStorage()._elemType = newValue}
    }
    /// Returns true if `elemType` has been explicitly set.
    public var hasElemType: Bool {return _storage._elemType != nil}
    /// Clears the value of `elemType`. Subsequent reads from it will return its default value.
    public mutating func clearElemType() {_uniqueStorage()._elemType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// map<K,V>
  public struct Map {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This field MUST have a valid TensorProto.DataType value
    /// This field MUST be present for this version of the IR.
    /// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
    public var keyType: Int32 {
      get {return _storage._keyType}
      set {_uniqueStorage()._keyType = newValue}
    }

    /// This field MUST be present for this version of the IR.
    public var valueType: Onnx_TypeProto {
      get {return _storage._valueType ?? Onnx_TypeProto()}
      set {_uniqueStorage()._valueType = newValue}
    }
    /// Returns true if `valueType` has been explicitly set.
    public var hasValueType: Bool {return _storage._valueType != nil}
    /// Clears the value of `valueType`. Subsequent reads from it will return its default value.
    public mutating func clearValueType() {_uniqueStorage()._valueType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Operator Sets
///
/// OperatorSets are uniquely identified by a (domain, opset_version) pair.
public struct Onnx_OperatorSetIdProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The domain of the operator set being identified.
  /// The empty string ("") or absence of this field implies the operator
  /// set that is defined as part of the ONNX specification.
  /// This field MUST be present in this version of the IR when referring to any other operator set.
  public var domain: String = String()

  /// The version of the operator set being identified.
  /// This field MUST be present in this version of the IR.
  public var version: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "onnx"

extension Onnx_Version: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "_START_VERSION"),
    1: .same(proto: "IR_VERSION_2017_10_10"),
    2: .same(proto: "IR_VERSION_2017_10_30"),
    3: .same(proto: "IR_VERSION_2017_11_3"),
    4: .same(proto: "IR_VERSION_2019_1_22"),
    5: .same(proto: "IR_VERSION_2019_3_18"),
    6: .same(proto: "IR_VERSION_2019_9_19"),
    7: .same(proto: "IR_VERSION"),
  ]
}

extension Onnx_AttributeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    21: .standard(proto: "ref_attr_name"),
    13: .standard(proto: "doc_string"),
    20: .same(proto: "type"),
    2: .same(proto: "f"),
    3: .same(proto: "i"),
    4: .same(proto: "s"),
    5: .same(proto: "t"),
    6: .same(proto: "g"),
    22: .standard(proto: "sparse_tensor"),
    7: .same(proto: "floats"),
    8: .same(proto: "ints"),
    9: .same(proto: "strings"),
    10: .same(proto: "tensors"),
    11: .same(proto: "graphs"),
    23: .standard(proto: "sparse_tensors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularFloatField(value: &self.f)
      case 3: try decoder.decodeSingularInt64Field(value: &self.i)
      case 4: try decoder.decodeSingularBytesField(value: &self.s)
      case 5: try decoder.decodeSingularMessageField(value: &self._t)
      case 6: try decoder.decodeSingularMessageField(value: &self._g)
      case 7: try decoder.decodeRepeatedFloatField(value: &self.floats)
      case 8: try decoder.decodeRepeatedInt64Field(value: &self.ints)
      case 9: try decoder.decodeRepeatedBytesField(value: &self.strings)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.tensors)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.graphs)
      case 13: try decoder.decodeSingularStringField(value: &self.docString)
      case 20: try decoder.decodeSingularEnumField(value: &self.type)
      case 21: try decoder.decodeSingularStringField(value: &self.refAttrName)
      case 22: try decoder.decodeSingularMessageField(value: &self._sparseTensor)
      case 23: try decoder.decodeRepeatedMessageField(value: &self.sparseTensors)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.f != 0 {
      try visitor.visitSingularFloatField(value: self.f, fieldNumber: 2)
    }
    if self.i != 0 {
      try visitor.visitSingularInt64Field(value: self.i, fieldNumber: 3)
    }
    if !self.s.isEmpty {
      try visitor.visitSingularBytesField(value: self.s, fieldNumber: 4)
    }
    if let v = self._t {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._g {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.floats.isEmpty {
      try visitor.visitPackedFloatField(value: self.floats, fieldNumber: 7)
    }
    if !self.ints.isEmpty {
      try visitor.visitPackedInt64Field(value: self.ints, fieldNumber: 8)
    }
    if !self.strings.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.strings, fieldNumber: 9)
    }
    if !self.tensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tensors, fieldNumber: 10)
    }
    if !self.graphs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.graphs, fieldNumber: 11)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 13)
    }
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 20)
    }
    if !self.refAttrName.isEmpty {
      try visitor.visitSingularStringField(value: self.refAttrName, fieldNumber: 21)
    }
    if let v = self._sparseTensor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }
    if !self.sparseTensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sparseTensors, fieldNumber: 23)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_AttributeProto, rhs: Onnx_AttributeProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.refAttrName != rhs.refAttrName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.type != rhs.type {return false}
    if lhs.f != rhs.f {return false}
    if lhs.i != rhs.i {return false}
    if lhs.s != rhs.s {return false}
    if lhs._t != rhs._t {return false}
    if lhs._g != rhs._g {return false}
    if lhs._sparseTensor != rhs._sparseTensor {return false}
    if lhs.floats != rhs.floats {return false}
    if lhs.ints != rhs.ints {return false}
    if lhs.strings != rhs.strings {return false}
    if lhs.tensors != rhs.tensors {return false}
    if lhs.graphs != rhs.graphs {return false}
    if lhs.sparseTensors != rhs.sparseTensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_AttributeProto.AttributeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "INT"),
    3: .same(proto: "STRING"),
    4: .same(proto: "TENSOR"),
    5: .same(proto: "GRAPH"),
    6: .same(proto: "FLOATS"),
    7: .same(proto: "INTS"),
    8: .same(proto: "STRINGS"),
    9: .same(proto: "TENSORS"),
    10: .same(proto: "GRAPHS"),
    11: .same(proto: "SPARSE_TENSOR"),
    12: .same(proto: "SPARSE_TENSORS"),
  ]
}

extension Onnx_ValueInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueInfoProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "doc_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._type)
      case 3: try decoder.decodeSingularStringField(value: &self.docString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_ValueInfoProto, rhs: Onnx_ValueInfoProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._type != rhs._type {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_NodeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "name"),
    4: .standard(proto: "op_type"),
    7: .same(proto: "domain"),
    5: .same(proto: "attribute"),
    6: .standard(proto: "doc_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.input)
      case 2: try decoder.decodeRepeatedStringField(value: &self.output)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeSingularStringField(value: &self.opType)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.attribute)
      case 6: try decoder.decodeSingularStringField(value: &self.docString)
      case 7: try decoder.decodeSingularStringField(value: &self.domain)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitRepeatedStringField(value: self.input, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedStringField(value: self.output, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.opType.isEmpty {
      try visitor.visitSingularStringField(value: self.opType, fieldNumber: 4)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 6)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_NodeProto, rhs: Onnx_NodeProto) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.name != rhs.name {return false}
    if lhs.opType != rhs.opType {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TrainingInfoProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainingInfoProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initialization"),
    2: .same(proto: "algorithm"),
    3: .standard(proto: "initialization_binding"),
    4: .standard(proto: "update_binding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._initialization)
      case 2: try decoder.decodeSingularMessageField(value: &self._algorithm)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.initializationBinding)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.updateBinding)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._initialization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._algorithm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.initializationBinding.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initializationBinding, fieldNumber: 3)
    }
    if !self.updateBinding.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateBinding, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TrainingInfoProto, rhs: Onnx_TrainingInfoProto) -> Bool {
    if lhs._initialization != rhs._initialization {return false}
    if lhs._algorithm != rhs._algorithm {return false}
    if lhs.initializationBinding != rhs.initializationBinding {return false}
    if lhs.updateBinding != rhs.updateBinding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_ModelProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ir_version"),
    8: .standard(proto: "opset_import"),
    2: .standard(proto: "producer_name"),
    3: .standard(proto: "producer_version"),
    4: .same(proto: "domain"),
    5: .standard(proto: "model_version"),
    6: .standard(proto: "doc_string"),
    7: .same(proto: "graph"),
    14: .standard(proto: "metadata_props"),
    20: .standard(proto: "training_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.irVersion)
      case 2: try decoder.decodeSingularStringField(value: &self.producerName)
      case 3: try decoder.decodeSingularStringField(value: &self.producerVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.domain)
      case 5: try decoder.decodeSingularInt64Field(value: &self.modelVersion)
      case 6: try decoder.decodeSingularStringField(value: &self.docString)
      case 7: try decoder.decodeSingularMessageField(value: &self._graph)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.opsetImport)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.metadataProps)
      case 20: try decoder.decodeRepeatedMessageField(value: &self.trainingInfo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.irVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.irVersion, fieldNumber: 1)
    }
    if !self.producerName.isEmpty {
      try visitor.visitSingularStringField(value: self.producerName, fieldNumber: 2)
    }
    if !self.producerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.producerVersion, fieldNumber: 3)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 4)
    }
    if self.modelVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.modelVersion, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 6)
    }
    if let v = self._graph {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.opsetImport.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.opsetImport, fieldNumber: 8)
    }
    if !self.metadataProps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataProps, fieldNumber: 14)
    }
    if !self.trainingInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trainingInfo, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_ModelProto, rhs: Onnx_ModelProto) -> Bool {
    if lhs.irVersion != rhs.irVersion {return false}
    if lhs.opsetImport != rhs.opsetImport {return false}
    if lhs.producerName != rhs.producerName {return false}
    if lhs.producerVersion != rhs.producerVersion {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.modelVersion != rhs.modelVersion {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs._graph != rhs._graph {return false}
    if lhs.metadataProps != rhs.metadataProps {return false}
    if lhs.trainingInfo != rhs.trainingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_StringStringEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringStringEntryProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_StringStringEntryProto, rhs: Onnx_StringStringEntryProto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TensorAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_name"),
    2: .standard(proto: "quant_parameter_tensor_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tensorName)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.quantParameterTensorNames)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorName, fieldNumber: 1)
    }
    if !self.quantParameterTensorNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantParameterTensorNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TensorAnnotation, rhs: Onnx_TensorAnnotation) -> Bool {
    if lhs.tensorName != rhs.tensorName {return false}
    if lhs.quantParameterTensorNames != rhs.quantParameterTensorNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_GraphProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GraphProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "name"),
    5: .same(proto: "initializer"),
    15: .standard(proto: "sparse_initializer"),
    10: .standard(proto: "doc_string"),
    11: .same(proto: "input"),
    12: .same(proto: "output"),
    13: .standard(proto: "value_info"),
    14: .standard(proto: "quantization_annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.node)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.initializer)
      case 10: try decoder.decodeSingularStringField(value: &self.docString)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.input)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.output)
      case 13: try decoder.decodeRepeatedMessageField(value: &self.valueInfo)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.quantizationAnnotation)
      case 15: try decoder.decodeRepeatedMessageField(value: &self.sparseInitializer)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.node, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.initializer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initializer, fieldNumber: 5)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 10)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.input, fieldNumber: 11)
    }
    if !self.output.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.output, fieldNumber: 12)
    }
    if !self.valueInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valueInfo, fieldNumber: 13)
    }
    if !self.quantizationAnnotation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.quantizationAnnotation, fieldNumber: 14)
    }
    if !self.sparseInitializer.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sparseInitializer, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_GraphProto, rhs: Onnx_GraphProto) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.name != rhs.name {return false}
    if lhs.initializer != rhs.initializer {return false}
    if lhs.sparseInitializer != rhs.sparseInitializer {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.input != rhs.input {return false}
    if lhs.output != rhs.output {return false}
    if lhs.valueInfo != rhs.valueInfo {return false}
    if lhs.quantizationAnnotation != rhs.quantizationAnnotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TensorProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dims"),
    2: .standard(proto: "data_type"),
    3: .same(proto: "segment"),
    4: .standard(proto: "float_data"),
    5: .standard(proto: "int32_data"),
    6: .standard(proto: "string_data"),
    7: .standard(proto: "int64_data"),
    8: .same(proto: "name"),
    12: .standard(proto: "doc_string"),
    9: .standard(proto: "raw_data"),
    13: .standard(proto: "external_data"),
    14: .standard(proto: "data_location"),
    10: .standard(proto: "double_data"),
    11: .standard(proto: "uint64_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.dims)
      case 2: try decoder.decodeSingularInt32Field(value: &self.dataType)
      case 3: try decoder.decodeSingularMessageField(value: &self._segment)
      case 4: try decoder.decodeRepeatedFloatField(value: &self.floatData)
      case 5: try decoder.decodeRepeatedInt32Field(value: &self.int32Data)
      case 6: try decoder.decodeRepeatedBytesField(value: &self.stringData)
      case 7: try decoder.decodeRepeatedInt64Field(value: &self.int64Data)
      case 8: try decoder.decodeSingularStringField(value: &self.name)
      case 9: try decoder.decodeSingularBytesField(value: &self.rawData)
      case 10: try decoder.decodeRepeatedDoubleField(value: &self.doubleData)
      case 11: try decoder.decodeRepeatedUInt64Field(value: &self.uint64Data)
      case 12: try decoder.decodeSingularStringField(value: &self.docString)
      case 13: try decoder.decodeRepeatedMessageField(value: &self.externalData)
      case 14: try decoder.decodeSingularEnumField(value: &self.dataLocation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dims, fieldNumber: 1)
    }
    if self.dataType != 0 {
      try visitor.visitSingularInt32Field(value: self.dataType, fieldNumber: 2)
    }
    if let v = self._segment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.floatData.isEmpty {
      try visitor.visitPackedFloatField(value: self.floatData, fieldNumber: 4)
    }
    if !self.int32Data.isEmpty {
      try visitor.visitPackedInt32Field(value: self.int32Data, fieldNumber: 5)
    }
    if !self.stringData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.stringData, fieldNumber: 6)
    }
    if !self.int64Data.isEmpty {
      try visitor.visitPackedInt64Field(value: self.int64Data, fieldNumber: 7)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 8)
    }
    if !self.rawData.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawData, fieldNumber: 9)
    }
    if !self.doubleData.isEmpty {
      try visitor.visitPackedDoubleField(value: self.doubleData, fieldNumber: 10)
    }
    if !self.uint64Data.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.uint64Data, fieldNumber: 11)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 12)
    }
    if !self.externalData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalData, fieldNumber: 13)
    }
    if self.dataLocation != .default {
      try visitor.visitSingularEnumField(value: self.dataLocation, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TensorProto, rhs: Onnx_TensorProto) -> Bool {
    if lhs.dims != rhs.dims {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs._segment != rhs._segment {return false}
    if lhs.floatData != rhs.floatData {return false}
    if lhs.int32Data != rhs.int32Data {return false}
    if lhs.stringData != rhs.stringData {return false}
    if lhs.int64Data != rhs.int64Data {return false}
    if lhs.name != rhs.name {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.rawData != rhs.rawData {return false}
    if lhs.externalData != rhs.externalData {return false}
    if lhs.dataLocation != rhs.dataLocation {return false}
    if lhs.doubleData != rhs.doubleData {return false}
    if lhs.uint64Data != rhs.uint64Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorProto.DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "UINT8"),
    3: .same(proto: "INT8"),
    4: .same(proto: "UINT16"),
    5: .same(proto: "INT16"),
    6: .same(proto: "INT32"),
    7: .same(proto: "INT64"),
    8: .same(proto: "STRING"),
    9: .same(proto: "BOOL"),
    10: .same(proto: "FLOAT16"),
    11: .same(proto: "DOUBLE"),
    12: .same(proto: "UINT32"),
    13: .same(proto: "UINT64"),
    14: .same(proto: "COMPLEX64"),
    15: .same(proto: "COMPLEX128"),
    16: .same(proto: "BFLOAT16"),
  ]
}

extension Onnx_TensorProto.DataLocation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "EXTERNAL"),
  ]
}

extension Onnx_TensorProto.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Onnx_TensorProto.protoMessageName + ".Segment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.begin)
      case 2: try decoder.decodeSingularInt64Field(value: &self.end)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.begin != 0 {
      try visitor.visitSingularInt64Field(value: self.begin, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt64Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TensorProto.Segment, rhs: Onnx_TensorProto.Segment) -> Bool {
    if lhs.begin != rhs.begin {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_SparseTensorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseTensorProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "indices"),
    3: .same(proto: "dims"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._values)
      case 2: try decoder.decodeSingularMessageField(value: &self._indices)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.dims)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._indices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.dims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dims, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_SparseTensorProto, rhs: Onnx_SparseTensorProto) -> Bool {
    if lhs._values != rhs._values {return false}
    if lhs._indices != rhs._indices {return false}
    if lhs.dims != rhs.dims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TensorShapeProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dim)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dim.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dim, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TensorShapeProto, rhs: Onnx_TensorShapeProto) -> Bool {
    if lhs.dim != rhs.dim {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TensorShapeProto.Dimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Onnx_TensorShapeProto.protoMessageName + ".Dimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dim_value"),
    2: .standard(proto: "dim_param"),
    3: .same(proto: "denotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .dimValue(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .dimParam(v)}
      case 3: try decoder.decodeSingularStringField(value: &self.denotation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .dimValue(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    case .dimParam(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if !self.denotation.isEmpty {
      try visitor.visitSingularStringField(value: self.denotation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TensorShapeProto.Dimension, rhs: Onnx_TensorShapeProto.Dimension) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.denotation != rhs.denotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypeProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_type"),
    4: .standard(proto: "sequence_type"),
    5: .standard(proto: "map_type"),
    6: .same(proto: "denotation"),
  ]

  fileprivate class _StorageClass {
    var _value: Onnx_TypeProto.OneOf_Value?
    var _denotation: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
      _denotation = source._denotation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Onnx_TypeProto.Tensor?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .tensorType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .tensorType(v)}
        case 4:
          var v: Onnx_TypeProto.Sequence?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .sequenceType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .sequenceType(v)}
        case 5:
          var v: Onnx_TypeProto.Map?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .mapType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .mapType(v)}
        case 6: try decoder.decodeSingularStringField(value: &_storage._denotation)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .tensorType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .sequenceType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .mapType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
      if !_storage._denotation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._denotation, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TypeProto, rhs: Onnx_TypeProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        if _storage._denotation != rhs_storage._denotation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Tensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Tensor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
    2: .same(proto: "shape"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.elemType)
      case 2: try decoder.decodeSingularMessageField(value: &self._shape)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elemType != 0 {
      try visitor.visitSingularInt32Field(value: self.elemType, fieldNumber: 1)
    }
    if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TypeProto.Tensor, rhs: Onnx_TypeProto.Tensor) -> Bool {
    if lhs.elemType != rhs.elemType {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Sequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Sequence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "elem_type"),
  ]

  fileprivate class _StorageClass {
    var _elemType: Onnx_TypeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elemType = source._elemType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._elemType)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._elemType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TypeProto.Sequence, rhs: Onnx_TypeProto.Sequence) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elemType != rhs_storage._elemType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_TypeProto.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Onnx_TypeProto.protoMessageName + ".Map"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .standard(proto: "value_type"),
  ]

  fileprivate class _StorageClass {
    var _keyType: Int32 = 0
    var _valueType: Onnx_TypeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyType = source._keyType
      _valueType = source._valueType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._keyType)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._valueType)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._keyType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._keyType, fieldNumber: 1)
      }
      if let v = _storage._valueType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_TypeProto.Map, rhs: Onnx_TypeProto.Map) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyType != rhs_storage._keyType {return false}
        if _storage._valueType != rhs_storage._valueType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Onnx_OperatorSetIdProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperatorSetIdProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.domain)
      case 2: try decoder.decodeSingularInt64Field(value: &self.version)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Onnx_OperatorSetIdProto, rhs: Onnx_OperatorSetIdProto) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
